<questions>

<question>
<catagory>0</catagory>
<no>0</no>
<q>"What will be the output if you compile and execute the following c code ?
int main()
{
    int i=320;
    char *ptr=(char *)&amp;i;
    printf("%d",*ptr);
    return 0;"
}</q>
<optiona>320</optiona>
<optionb>1</optionb>
<optionc>64</optionc>
<optiond>compiler error</optiond>
<ans>3</ans>
<info>1</info>
<data>As we know size of int data type is two byte while char pointer can point to one byte at a time. So char pointer is pointing to only the first byte. And its value will be 0100000</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>Which of the following statements should be used to obtain a remainder after dividing 3.14 by 2.1 ?</q>
<optiona>rem = 3.14 % 2.1;</optiona>
<optionb>rem = modf(3.14, 2.1);</optionb>
<optionc>rem = fmod(3.14, 2.1);</optionc>
<optiond>Remainder cannot be obtain in floating point division.</optiond>
<ans>3</ans>
<info>1</info>
<data>fmod(x,y) - Calculates x modulo y, the remainder of x/y.This function is the same as the modulus operator. But fmod() performs floating point divisions. 
Example:


int main ()
{
  printf ("fmod of 3.14/2.1 is %lf\n", fmod (3.14,2.1) );
  return 0;
}
Output:
fmod of 3.14/2.1 is 1.040000
</data>
</question>

<question>
<catagory>0</catagory>
<no>0</no>
<q>What are the types of linkages?</q>
<optiona>Internal and External</optiona>
<optionb>External, Internal and None</optionb>
<optionc>External and None</optionc>
<optiond>Internal</optiond>
<ans>2</ans>
<info>1</info>
<data>External Linkage-> means global, non-static variables and functions. Internal Linkage-> means static variables and functions with file scope.None Linkage-> means Local variables.</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>Is there any difference between following declarations? 
1 :	extern int fun(); 
2 :	int fun();</q>
<optiona>Both are identical</optiona>
<optionb>No difference, except extern int fun(); is probably in another file</optionb>
<optionc>int fun(); is overrided with extern int fun();</optionc>
<optiond>None of these</optiond>
<ans>2</ans>
<info>1</info>
<data>Extern int fun(); declaration in C is to indicate the existence of a global function and it is defined externally to the current module or in another file. int fun(); declaration in C is to indicate the existence of a function inside the current module or in the same file.</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>Which of the following special symbol allowed in a variable name?</q>
<optiona>* (asterisk)</optiona>
<optionb>| (pipeline)</optionb>
<optionc>- (hyphen)</optionc>
<optiond>_ (underscore)</optiond>
<ans>4</ans>
<info>1</info>
<data>Variable names in C are made up of letters (upper and lower case) and digits. The underscore character ("_") is also permitted. Names must not begin with a digit. 
Examples of valid (but not very descriptive) C variable names:
=> foo 
=> Bar 
=> BAZ 
=> foo_bar 
=> _foo42 
=> _ 
=> QuUx </data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>How would you round off a value from 1.66 to 2.0?</q>
<optiona>ceil(1.66)</optiona>
<optionb>floor(1.66)</optionb>
<optionc>roundup(1.66)</optionc>
<optiond>roundto(1.66)</optiond>
<ans>1</ans>
<info>1</info>
<data>/* Example for ceil() and floor() functions: */

int main()
{
    printf("\n Result : %f" , ceil(1.44) );
    printf("\n Result : %f" , ceil(1.66) );
 
    printf("\n Result : %f" , floor(1.44) );    
    printf("\n Result : %f" , floor(1.66) );

    return 0;
}
// Output:
// Result : 2.000000
// Result : 2.000000
// Result : 1.000000
// Result : 1.000000</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>By default a real number is treated as a</q>
<optiona>float</optiona>
<optionb>double</optionb>
<optionc>long double</optionc>
<optiond>far double</optiond>
<ans>2</ans>
<info>1</info>
<data>In computing, 'real number' often refers to non-complex floating-point numbers. It include both rational numbers, such as 42 and 3/4, and irrational numbers such as pi = 3.14159265... When the accuracy of the floating point number is insufficient, we can use the double to define the number. The double is same as float but with longer precision and takes double space (8 bytes) than float. To extend the precision further we can use long double which occupies 10 bytes of memory space. </data>
</question>

<question>
<catagory>0</catagory>
<no>0</no>
<q>Which of the following is not user defined data type?
1. struct booklong int l = 2.35;
{
    char name[10];
    float price;
    int pages;
};
2. long int l = 2.35;
3. enum day {Sun, Mon, Tue, Wed};  
</q>
<optiona>1</optiona>
<optionb>2</optionb>
<optionc>3</optionc>
<optiond>both 1 and 2</optiond>
<ans>2</ans>
<info>1</info>
<data> data types classification are

Primary data types

int
char
float
double
void

Secondary data types (or) User-defined data type

Array
Pointer
Structure
Union
Enum

So, clearly long int l = 2.35; is not User-defined data type. 
(i.e.long int l = 2.35; is the answer.)</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>Identify which of the following are declarations
1 :	extern int x;
2 :	float square ( float x ) { ... }
3 :	double pow(double, double);</q>
<optiona>1</optiona>
<optionb>2</optionb>
<optionc>1 and 3</optionc>
<optiond>3</optiond>
<ans>3</ans>
<info>1</info>
<data>extern int x; - is an external variable declaration. double pow(double, double); - is a function prototype declaration. Therefore, 1 and 3 are declarations. 2 is definition.</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What is the output of the program given below ?
int main()
{
    enum status { pass, fail, atkt};
    enum status stud1, stud2, stud3;
    stud1 = pass;
    stud2 = atkt;
    stud3 = fail;
    printf("%d, %d, %d\n", stud1, stud2, stud3);
    return 0;
}</q>
<optiona>0,1,2</optiona>
<optionb>1,2,3</optionb>
<optionc>0,1,2</optionc>
<optiond>1,3,2</optiond>
<ans>3</ans>
<info>1</info>
<data>enum takes the format like {0,1,2..) so pass=0, fail=1, atkt=2 stud1 = pass (value is 0) stud2 = atkt (value is 2) stud3 = fail (value is 1) Hence it prints 0, 2, 1</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>In mathematics and computer programming, which is the correct order of mathematical operators ?</q>
<optiona>Addition, Subtraction, Multiplication, Division</optiona>
<optionb>Division, Multiplication, Addition, Subtraction</optionb>
<optionc>Multiplication, Addition, Division, Subtraction</optionc>
<optiond>Addition, Division, Modulus, Subtraction</optiond>
<ans>2</ans>
<info>1</info>
<data>Simply called as BODMAS (Brackets, Order, Division, Multiplication, Addition and Subtraction).
Mnemonics are often used to help students remember the rules, but the rules taught by the use of acronyms can be misleading. In the United States the acronym PEMDAS is common. It stands for Parentheses, Exponents, Multiplication, Division, Addition, Subtraction. In other English speaking countries, Parentheses may be called Brackets, or symbols of inclusion and Exponentiation may be called either Indices, Powers or Orders, and since multiplication and division are of equal precedence, M and D are often interchanged, leading to such acronyms as BEDMAS, BIDMAS, BODMAS, BERDMAS, PERDMAS, and BPODMAS.</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>Which of the following is not logical operator?</q>
<optiona>&amp;</optiona>
<optionb>&amp;&amp;</optionb>
<optionc>||</optionc>
<optiond>!</optiond>
<ans>1</ans>
<info>1</info>
<data>Bitwise operators:
&amp; is a Bitwise AND operator.

Logical operators:
&amp;&amp; is a Logical AND operator. 
|| is a Logical OR operator. 
! is a NOT operator.
So, '&amp;' is not a Logical operator.</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>How many times the while loop will get executed if a short int is 2 byte wide?

int main()
{
    int j=1;
    while(j &lt;= 255)
    {
	printf("%c %d\n", j, j);
	j++;
    }
    return 0;
}</q>
<optiona>Infinite times</optiona>
<optionb>255</optionb>
<optionc>256</optionc>
<optiond>254</optiond>
<ans>2</ans>
<info>1</info>
<data>The while(j &lt;= 255) loop will get executed 255 times. The size short int(2 byte wide) does not affect the while() loop.</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>How many times "jaApps" is get printed?
int main()
{
    int x;
    for(x=-1; x&lt;=10; x++)
    {
        if(x &lt; 5)
            continue;
        else
            break;
        printf("jaApps");
    }
    return 0;
}</q>
<optiona>Infinite times</optiona>
<optionb>11</optionb>
<optionc>0</optionc>
<optiond>12</optiond>
<ans>3</ans>
<info>0</info>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>Which of the following cannot be checked in a switch-case statement?</q>
<optiona>Character</optiona>
<optionb>Integer</optionb>
<optionc>Float</optionc>
<optiond>enum</optiond>
<ans>3</ans>
<info>1</info>
<data>The switch/case statement in the c language is defined by the language specification to use an int value, so you can not use a float value.
switch( expression )
{
    case const expr1:    stmnts 1;
    case const expr2:    stmnts 2;    
    case const expr3:    stmnts 3;
    ...
    ...
    default : stmnts 4;
}
The value of the 'expression' in a switch-case statement must be an integer, char, short, long. Float and double are not allowed.
</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What will be the output of the program?

int main()
{
    int i=0;
    for(; i&lt;=5; i++);
        printf("%d", i);
    return 0;
}</q>
<optiona>0, 1, 2, 3, 4, 5</optiona>
<optionb>5</optionb>
<optionc>0, 1, 2, 3, 4</optionc>
<optiond>6</optiond>
<ans>4</ans>
<info>1</info>
<data>STEP 1: int i = 0; here variable i is an integer type and initialized to '0'.

STEP 2: for(; i&lt;=5; i++); variable i=0 is already assigned in previous step. The semi-colon at the end of this for loop tells, "there is no more statement is inside the loop".

Loop 1: here i=0, the condition in for(; 0&lt;=5; i++) loop satisfies and then i is incremented by '1'(one)
Loop 2: here i=1, the condition in for(; 1&lt;=5; i++) loop satisfies and then i is incremented by '1'(one)
Loop 3: here i=2, the condition in for(; 2&lt;=5; i++) loop satisfies and then i is incremented by '1'(one)
Loop 4: here i=3, the condition in for(; 3&lt;=5; i++) loop satisfies and then i is increemented by '1'(one)
Loop 5: here i=4, the condition in for(; 4&lt;=5; i++) loop satisfies and then i is incremented by '1'(one)
Loop 6: here i=5, the condition in for(; 5&lt;=5; i++) loop satisfies and then i is incremented by '1'(one)
Loop 7: here i=6, the condition in for(; 6&lt;=5; i++) loop fails and then i is not incremented.
Step 3: printf("%d", i); here the value of i is 6. Hence the output is '6'.
</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>Which of the following cannot be checked in a switch-case statement?</q>
<optiona>Character</optiona>
<optionb>Integer</optionb>
<optionc>Float</optionc>
<optiond>enum</optiond>
<ans>3</ans>
<info>1</info>
<data>The switch/case statement in the c language is defined by the language specification to use an int value, so you can not use a float value.
switch( expression )
{
    case const expr1:    stmnts 1;
    case const expr2:    stmnts 2;    
    case const expr3:    stmnts 3;
    ...
    ...
    default : stmnts 4;
}</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What will be the output of the program?

int main()
{
    char str[]="C-program";
    int a = 5;
    printf(a >10?"Ps\n":"%s\n", str);
    return 0;
}</q>
<optiona>C-program</optiona>
<optionb>Ps</optionb>
<optionc>Error</optionc>
<optiond>None of the above</optiond>
<ans>1</ans>
<info>1</info>
<data>Step 1: char str[]="C-program"; here variable str contains "C-program".
Step 2: int a = 5; here variable a contains "5".
Step 3: printf(a >10?"Ps\n":"%s\n", str); this statement can be written as
if(a > 10)
{
    printf("Ps\n");
}
else
{
    printf("%s\n", str);
}
Here we are checking a > 10 means 5 > 10. Hence this condition will be failed. So it prints variable str.

Hence the output is "C-program".</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What will be the output of the program?
int main()
{
    int a = 500, b = 100, c;
    if(!a >= 400)
        b = 300;
    c = 200;
    printf("b = %d c = %d\n", b, c);
    return 0;
}
</q>
<optiona>b = 300 c = 200</optiona>
<optionb>b = 100 c = garbage</optionb>
<optionc>b = 300 c = garbage</optionc>
<optiond>b = 100 c = 200</optiond>
<ans>4</ans>
<info>1</info>
<data>Initially variables a = 500, b = 100 and c is not assigned.

Step 1: if(!a >= 400)
Step 2: if(!500 >= 400)
Step 3: if(0 >= 400)
Step 4: if(FALSE) Hence the if condition is failed.
Step 5: So, variable c is assigned to a value '200'.
Step 6: printf("b = %d c = %d\n", b, c); It prints value of b and c.
Hence the output is "b = 100 c = 200"</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What will be the output of the program?
int main()
{
    unsigned int i = 65535; /* Assume 2 byte integer*/
    while(i++ != 0)
        printf("%d",++i);
    printf("\n");
    return 0;
}</q>
<optiona>Infinite loop</optiona>
<optionb>0 1 2 ... 65535</optionb>
<optionc>0 1 2 ... 32767 - 32766 -32765 -1 0</optionc>
<optiond>No output</optiond>
<ans>1</ans>
<info>1</info>
<data>Here unsigned int size is 2 bytes. It varies from 0,1,2,3, ... to 65535.

Step 1:unsigned int i = 65535;

Step 2:
Loop 1: while(i++ != 0) this statement becomes while(65535 != 0). Hence the while(TRUE) condition is satisfied. Then the printf("%d", ++i); prints '1'(variable 'i' is already increemented by '1' in while statement and now increemented by '1' in printf statement) Loop 2: while(i++ != 0) this statement becomes while(1 != 0). Hence the while(TRUE) condition is satisfied. Then the printf("%d", ++i); prints '3'(variable 'i' is already increemented by '1' in while statement and now increemented by '1' in printf statement)
....
....
The while loop will never stops executing, because variable i will never become '0'(zero). Hence it is an 'Infinite loop'.</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What will be the output of the program?
int main()
{
    int x = 3;
    float y = 3.0;
    if(x == y)
        printf("x and y are equal");
    else
        printf("x and y are not equal");
    return 0;
}</q>
<optiona>x and y are equal</optiona>
<optionb>x and y are not equal</optionb>
<optionc>unpredictable</optionc>
<optiond>no output</optiond>
<ans>1</ans>
<info>1</info>
<data>Step 1: int x = 3; here variable x is an integer type and initialized to '3'.

Step 2: float y = 3.0; here variable y is an float type and initialized to '3.0'

Step 3: if(x == y) here we are comparing if(3 == 3.0) hence this condition is satisfied. 
Hence it prints "x and y are equal".</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What will be the output of the program, if a short int is 2 bytes wide?
int main()
{
    short int i = 0;
    for(i&lt;=5 &amp;&amp; i>=-1; ++i; i>0)
        printf("%u,", i);
    return 0;
}</q>
<optiona>1 ... 65535</optiona>
<optionb>Expression syntax error</optionb>
<optionc>No output</optionc>
<optiond>0, 1, 2, 3, 4, 5</optiond>
<ans>1</ans>
<info>1</info>
<data>for(i&lt;=5 &amp;&amp; i>=-1; ++i; i>0) so expression i&lt;=5 &amp;&amp;  i>=-1 initializes for loop. expression ++i is the loop condition. expression i>0 is the increment expression.

In for( i &lt;= 5 &amp;&amp; i >= -1; ++i; i>0) expression i&lt;=5 &amp;&amp; i>=-1 evaluates to one.

Loop condition always get evaluated to true. Also at this point it increases i by one.

An increment_expression i>0 has no effect on value of i.so for loop get executed till the limit of integer (ie. 65535)</data>
</question>


<question>
<catagory>0</catagory>
<no>0</no>
<q>What will be the output of the program?
int main()
{
    char ch;
    if(ch = printf(""))
        printf("It matters\n");
    else
        printf("It doesn't matters\n");
    return 0;
}</q>
<optiona>It matters</optiona>
<optionb>It doesn't matters</optionb>
<optionc>matters</optionc>
<optiond>No output</optiond>
<ans>2</ans>
<info>1</info>
<data>printf() returns the number of charecters printed on the console.
Step 1: if(ch = printf("")) here printf() does not print anything, so it returns '0'(zero). 
Step 2: if(ch = 0) here variable ch has the value '0'(zero). 
Step 3: if(0) Hence the if condition is not satisfied. So it prints the else statements. 
Hence the output is "It doesn't matters".

Note: Compiler shows a warning "possibly incorrect assinment".</data>
</question>


</questions>
